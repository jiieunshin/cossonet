#' Load a matrix from a file
#'
#' The predict.cdcosso function is a function that receives the object and test data (testx) of the cdcosso package as input
#' and generates a predicted value for the test data.
#' This function uses the given test data to calculate predictions from the weights and biases generated by the model.
#'
#' @param n The number of observation of a example dataset.
#' @param p Dimension of a example dataset.
#' @param rho Correlation for first five significance variables.
#' @param SNR Signal-to-noise ratio.
#' @param response Type of response variable.
#'
#' @return a list containing the predicted value for the test data (f.new) and the transformed value of that predicted value (mu.new).
#' @export
data_generation = function(n, p, rho, SNR,
                           response = c("regression", "classification", "count", "survival", "interaction")){

  if(response == "classification"){
    # f1 = function(t) t - .5
    # f2 = function(t) (2 * t - 1)^2 - .4
    # f3 = function(t) sin(2 * pi * t) / (2 - sin(2 * pi * t)) - .1
    # f4 = function(t) 0.1*sin(2 * pi * t) + 0.2*cos(2 * pi * t) + 0.3*sin(2 * pi * t)^2 + 0.4*cos(2 * pi * t)^3 + 0.5*sin(2 * pi * t)^3
  f1 = function(t) 3 * t
  f2 = function(t) pi * sin(pi * t) * 2
  f3 = function(t) 8 * t^3
  f4 = function(t) 4/ (exp(1) - 1) * exp(t)
  }

  if(response == "regression"){
  f1 = function(t) t^3
  f2 = function(t) (2 * t - 1)^2
  f3 = function(t) sin(2 * pi * t) / (2 - sin(2 * pi * t))
  f4 = function(t) 0.1*sin(2 * pi * t) + 0.2*cos(2 * pi * t) + 0.3*sin(2 * pi * t)^2 + 0.4*cos(2 * pi * t)^3 + 0.5*sin(2 * pi * t)^3
  }

  if(response == "count"){
    f1 = function(t) t^3
    f2 = function(t) (2 * t - 1)^2
    f3 = function(t) sin(2 * pi * t) / (2 - sin(2 * pi * t))
    f4 = function(t) 0.1*sin(2 * pi * t) + 0.2*cos(2 * pi * t) + 0.3*sin(2 * pi * t)^2 + 0.4*cos(2 * pi * t)^3 + 0.5*sin(2 * pi * t)^3
  }

  if(response == "survival"){
    f1 = function(t) t^3
    f2 = function(t) (2 * t - 1)^2
    f3 = function(t) sin(2 * pi * t) / (2 - sin(2 * pi * t))
    f4 = function(t) 0.1*sin(2 * pi * t) + 0.2*cos(2 * pi * t) + 0.3*sin(2 * pi * t)^2 + 0.4*cos(2 * pi * t)^3 + 0.5*sin(2 * pi * t)^3
  }

  if(missing(response))
    type = "classification"
  response = match.arg(response)

  if(missing(n)) n = 200
  if(missing(p)) p = 10
  if(missing(rho)) rho = 0.8
  if(missing(SNR)) SNR = 8

  if(p <= 5) stop("dimension size should be larger than 5.")

  # Sigma = matrix(rho, 4, 4)
  # diag(Sigma) = 1

  # Sigma = matrix(1, 4, 4)
  # for(j in 1:4){
  #   for(k in 1:4){
  #     Sigma[j, k] = rho^abs(j-k)
  #   }
  # }


  # x = apply(rmvnorm(n, sigma = Sigma), 2, rescale)

  t = 2
  pp = 4
  x = matrix(0, n, pp)
  W = matrix(runif(n * pp), n, pp)
  U = runif(n)
  for(j in 1:pp){
    x[, j] = (W[, j] + t * U)/(1 + t)
  }

  # Set the outer margins
  # par(oma = c(0, 0, 0, 0))
  # Set the inner margin
  # par(mar = c(4, 4, 3, 1))
  # par(mfrow = c(1,4))
  # curve(f1, 0, 1)
  # curve(f2, 0, 1)
  # curve(f3, 0, 1)
  # curve(f4, 0, 1)
  # par(mfrow = c(1,1))
  # f = function(t) t/2 - (2 * t - 1)^2 + (sin(2 * pi * t) / (2 - sin(2 * pi * t))) - (0.1*sin(2 * pi * t) + 0.2*cos(2 * pi * t) + 0.3*sin(2 * pi * t)^2 + 0.4*cos(2 * pi * t)^3 + 0.5*sin(2 * pi * t)^3) + 1.5
  # curve(f, 0, 1)

  if(response == "regression"){
    V_sig = var(1 * f1(x[,1])) + var(1 * f2(x[,2])) + var(2 * f3(x[,3])) + var(3 * f4(x[,4]))
    sd = sqrt(V_sig / SNR)
    f = 1 * f1(x[,1]) + 1 * f2(x[,2]) + 2 * f3(x[,3]) + 3 * f4(x[,4]) + rnorm(n, 0, sd)

    # V_sig = var(5 * f1(x[,1])) + var(3 * f2(x[,2])) + var(4 * f3(x[,3])) + var(6 * f4(x[,4]))
    # sd = sqrt(V_sig / SNR)
    # f = 5 * f1(x[,1]) + 3 * f2(x[,2]) + 4 * f3(x[,3]) + 6 * f4(x[,4]) + rnorm(n, 0, sd)

    # x_nois = apply(matrix(rnorm(n * (p-4), 0, sd/sqrt(p-4)), n, (p-4)), 2, rescale)
    x_nois = matrix(runif(n * (p-pp), 0, 1), n, (p-pp))
    x = cbind(x, x_nois)

    out = list(x = x, y = f)
  }

  if(response == "classification"){
    V_sig = var(f1(x[,1])) + var(f2(x[,2])) + var(f3(x[,3])) + var(f4(x[,4]))
    sd = sqrt(V_sig / SNR)
    f = f1(x[,1]) + f2(x[,2]) + f3(x[,3]) + f4(x[,4]) - 10 + rnorm(n, 0, sd)

    # x_nois = apply(matrix(rnorm(n * (p-4), 0, sd/sqrt(p-4)), n, (p-4)), 2, rescale)
    x_nois = matrix(runif(n * (p-4), 0, 1), n, (p-4))
    x = cbind(x, x_nois)
    prob = exp(f)/(exp(f) + 1)
    y = rbinom(n, 1, prob)
    # plot(prob)
    # print(table(y))
    out = list(x = x, f = f, y = y)
  }

  if(response == "count"){
    V_sig = var(1 * f1(x[,1])) + var(1 * f2(x[,2])) + var(2 * f3(x[,3])) + var(3 * f4(x[,4]))
    sd = sqrt(V_sig / SNR)
    f = 1 * f1(x[,1]) + 1 * f2(x[,2]) + 2 * f3(x[,3]) + 3 * f4(x[,4]) + rnorm(n, 0, sd)


    # V_sig = var(1 * f1(x[,1])) + var(1 * f2(x[,2])) + var(2 * f3(x[,3])) + var(3 * f4(x[,4]))
    # sd = sqrt(V_sig / SNR)
    # f = 1 * f1(x[,1]) + 1 * f2(x[,2]) + 2 * f3(x[,3]) + 3 * f4(x[,4]) + rnorm(n, 0, sd)

    plot(f)

    # x_nois = apply(matrix(rnorm(n * (p-4), 0, sd/sqrt(p-4)), n, (p-4)), 2, rescale)
    x_nois = matrix(runif(n * (p-pp), 0, 1), n, (p-pp))
    x = cbind(x, x_nois)

    # f2 = 2 * (log(f) / max(log(f)))
    f = f / 3
    # f2 = (exp(f) / (1 + exp(f)) + 1)
    # f2 = (f - min(f)) / (min(f) - max(f)) * 2
    plot(f)
    mu = exp(f)
    y = rpois(n, mu)
    out = list(x = x, f = f, y = y)
  }

  if(response == 'survival'){

    V_sig = var(1 * f1(x[,1])) + var(1 * f2(x[,2])) + var(2 * f3(x[,3])) + var(3 * f4(x[,4]))
    sd = sqrt(V_sig / SNR)
    f = 1 * f1(x[,1]) + 1 * f2(x[,2]) + 2 * f3(x[,3]) + 3 * f4(x[,4]) + rnorm(n, 0, sd)

    x_nois = matrix(runif(n * (p - pp), 0, 1), n, (p - pp))
    x = cbind(x, x_nois)
    surTime = rexp(n, exp(f))
    cenTime = rexp(n, exp(-f) * runif(1, 4, 6))


    y = cbind(time = apply(cbind(surTime, cenTime), 1, min), status = 1 * (surTime < cenTime))

    out = list(x = x, f = f, y = y)
  }
  return(out)
}

# library(tmvtnorm)
