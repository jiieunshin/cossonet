true_var = c(rep(1, p_sig), rep(0, p-p_sig))
en1_signal_varsel[i, ] = ifelse(fit10$theta_step$theta.new[1:p_sig] > 0, 1, 0)
en1_true = ifelse(fit10$theta_step$theta.new > 0, 1, 0)
en1_varsel[i] = sum(en1_true)
en1_tp[i] = metric(true_var, en1_true)$tp
en1_fp[i] = metric(true_var, en1_true)$fp
en1_pre[i] = metric(true_var, en1_true)$precision
en1_rec[i] = metric(true_var, en1_true)$recall
en1_f1[i] = metric(true_var, en1_true)$f1_score
en1_pred = cossonet.predict(fit10, te_x)
# en1_miss[i] = mean(te_y != ifelse(en1_pred$mu.new < 0.5, 0, 1))
en1_miss[i] = mean((te_y - en1_pred$f.new)^2)
# en1_miss[i] = mean(-poisson()$dev.resids(te_y, en1_pred$mu.new, rep(1, te_n)))
en1_time[i] = mean(t2)
}
}
out$n[ll] = n
out$p[ll] = p
out$gamma[[ll]] = 1
out$tp[ll] = round(mean(en3_tp, na.rm = TRUE), 4)
out$tp_se[ll] = round(sd(en3_tp, na.rm = TRUE)/sqrt(sum(!is.na(en3_tp))), 4)
out$fp[ll] = round(mean(en3_fp, na.rm = TRUE), 4)
out$fp_se[ll] = round(sd(en3_fp, na.rm = TRUE)/sqrt(sum(!is.na(en3_fp))), 4)
out$f1[ll] = round(mean(en3_f1, na.rm = TRUE), 4)
out$f1_se[ll] = round(sd(en3_f1, na.rm = TRUE)/sqrt(sum(!is.na(en3_f1))), 4)
out$miss[ll] = round(mean(en3_miss, na.rm = TRUE), 4)
out$miss_se[ll] = round(sd(en3_miss, na.rm = TRUE)/sqrt(sum(!is.na(en3_miss))), 4)
out$time[[ll]] = round(mean(en3_time, na.rm = TRUE), 4)
out$time_se[[ll]] = round(sd(en3_time, na.rm = TRUE)/sqrt(sum(!is.na(en3_time))), 4)
ll = ll + 1
out$n[ll] = n
out$p[ll] = p
out$gamma[[ll]] = 0.95
out$tp[ll] = round(mean(en1_tp, na.rm = TRUE), 4)
out$tp_se[ll] = round(sd(en1_tp, na.rm = TRUE)/sqrt(sum(!is.na(en1_tp))), 4)
out$fp[ll] = round(mean(en1_fp, na.rm = TRUE), 4)
out$fp_se[ll] = round(sd(en1_fp, na.rm = TRUE)/sqrt(sum(!is.na(en1_fp))), 4)
out$f1[ll] = round(mean(en1_f1, na.rm = TRUE), 4)
out$f1_se[ll] = round(sd(en1_f1, na.rm = TRUE)/sqrt(sum(!is.na(en1_f1))), 4)
out$miss[ll] = round(mean(en1_miss, na.rm = TRUE), 4)
out$miss_se[ll] = round(sd(en1_miss, na.rm = TRUE)/sqrt(sum(!is.na(en1_miss))), 4)
out$time[[ll]] = round(mean(en1_time, na.rm = TRUE), 4)
out$time_se[[ll]] = round(sd(en1_time, na.rm = TRUE)/sqrt(sum(!is.na(en1_time))), 4)
if(i == iter){
print(Sys.time())
cat("\n n :", n, ", p = ", d, "-------------------------- \n")
cat("\n iteration :", i, "\n")
cat('gamma=1 \n')
cat("length :", sum(!is.na(en3_miss)), "\n")
cat("time :", round(mean(en3_time, na.rm = TRUE), 4), "(", round(sd(en3_time, na.rm = TRUE)/sqrt(sum(!is.na(en3_time))), 4), ")", "\n")
cat('varsel :', colSums(en3_signal_varsel), mean(en3_varsel, na.rm = TRUE) ,"(", round(sd(en3_varsel, na.rm = TRUE)/sqrt(iter), 4), ")", "\n")
cat('tp :', round(mean(en3_tp, na.rm = TRUE), 4), "(", round(sd(en3_tp, na.rm = TRUE)/sqrt(sum(!is.na(en3_tp))), 4), ")", "\n")
cat('fp :', round(mean(en3_fp, na.rm = TRUE), 4), "(", round(sd(en3_fp, na.rm = TRUE)/sqrt(sum(!is.na(en3_fp))), 4), ")", "\n")
cat('precis :', round(mean(en3_pre, na.rm = TRUE), 4), "(", round(sd(en3_pre, na.rm = TRUE)/sqrt(sum(!is.na(en3_pre))), 4), ")", "\n")
cat('reccall:', round(mean(en3_rec, na.rm = TRUE), 4), "(", round(sd(en3_rec, na.rm = TRUE)/sqrt(sum(!is.na(en3_rec))), 4), ")", "\n")
cat('f1     :', round(mean(en3_f1, na.rm = TRUE), 4), "(", round(sd(en3_f1, na.rm = TRUE)/sqrt(sum(!is.na(en3_f1))), 4), ")", "\n")
cat('miss   :', round(mean(en3_miss, na.rm = TRUE), 4), "(", round(sd(en3_miss, na.rm = TRUE)/sqrt(sum(!is.na(en3_miss))), 4), ")", "\n")
# cat('time   :', round(mean(time3, na.rm = TRUE), 4), "(", round(sd(time3, na.rm = TRUE)/sqrt(sum(!is.na(time3))), 4), ")", "\n")
cat('gamma=0.95 \n')
cat("length :", sum(!is.na(en1_miss)), "\n")
cat("time :", round(mean(en1_time, na.rm = TRUE), 4), "(", round(sd(en1_time, na.rm = TRUE)/sqrt(sum(!is.na(en1_time))), 4), ")", "\n")
cat('varsel :', colSums(en1_signal_varsel), mean(en1_varsel, na.rm = TRUE) ,"(", round(sd(en1_varsel, na.rm = TRUE)/sqrt(iter), 4), ")", "\n")
cat('tp :', round(mean(en1_tp, na.rm = TRUE), 4), "(", round(sd(en1_tp, na.rm = TRUE)/sqrt(sum(!is.na(en1_tp))), 4), ")", "\n")
cat('fp :', round(mean(en1_fp, na.rm = TRUE), 4), "(", round(sd(en1_fp, na.rm = TRUE)/sqrt(sum(!is.na(en1_fp))), 4), ")", "\n")
cat('precis :', round(mean(en1_pre, na.rm = TRUE), 4), "(", round(sd(en1_pre, na.rm = TRUE)/sqrt(sum(!is.na(en1_pre))), 4), ")", "\n")
cat('reccall:', round(mean(en1_rec, na.rm = TRUE), 4), "(", round(sd(en1_rec, na.rm = TRUE)/sqrt(sum(!is.na(en1_rec))), 4), ")", "\n")
cat('f1     :', round(mean(en1_f1, na.rm = TRUE), 4), "(", round(sd(en1_f1, na.rm = TRUE)/sqrt(sum(!is.na(en1_f1))), 4), ")", "\n")
cat('miss   :', round(mean(en1_miss, na.rm = TRUE), 4), "(", round(sd(en1_miss, na.rm = TRUE)/sqrt(sum(!is.na(en1_miss))), 4), ")", "\n")
# cat('time   :', round(mean(time10, na.rm = TRUE), 4), "(", round(sd(time10, na.rm = TRUE)/sqrt(sum(!is.na(time10))), 4), ")", "\n")
}
}
}
out
devtools::build_vignettes()
usethis::use_vignette("cossonet")
install.packages("devtools")
install.packages("devtools")
usethis::use_testthat()
usethis::use_test("cossonet")
devtools::document()
usethis::proj_get()
remove.packages("testthat")
install.packages("testthat")
library(testthat)
install.packages("testthat")
remove.packages("rhub")
pkg_install("rhub")
install.packages("rhub")
rhub::rhub_setup()
rhub::rhub_doctor()
rhub::rhub_check()
rc_new_token()
rc_new_token()
rhub::rc_new_token()
rc_submit()
rhub::rc_submit()
rhub::rhub_setup()
rhub::rhub_doctor()
rhub::rhub_check()
rhub::rc_new_token()
rhub:rc_submit()
rhub::rc_submit()
devtools::check()
check_win_r()
devtools::check_win_r()
rhub::rhub_setup()
rhub::rhub_doctor()
rhub::rhub_check()
rhub::rc_new_token()
rhub::rc_new_token()
rhub::rc_submit()
rhub::rhub_setup()
rhub::rhub_doctor()
rhub::rhub_check()
rhub::rc_new_token()
rhub::rc_submit()
rhub::rhub_setup()
rhub::rhub_doctor()
rhub::rhub_check()
rhub::rc_new_token()
rhub::rc_submit()
rhub::rhub_setup()
rhub::rhub_doctor()
rhub::rhub_check()
rhub::rc_new_token()
rhub::rc_submit()
rhub::rhub_setup()
rhub::rhub_doctor()
rhub::rhub_check()
rhub::rc_new_token()
rhub::rc_submit()
rhub::rhub_setup()
rhub::rhub_doctor()
rhub::rhub_check()
rhub::rc_new_token()
rhub::rc_submit()
rhub::rhub_setup()
rhub::rhub_doctor()
rhub::rhub_check()
rhub::rc_new_token()
rhub::rc_submit()
remove.packages("cossonet")
devtools::install_github("jiieunshin/cossonet")
library(cossonet)
library(tmvtnorm)
library(glmnet)
library(cosso)
library(MASS)
n = 100
te_n = 1000
p_sig = 4
p = 160
out2 = out
out = matrix(0, 24, 13)
colnames(out) = c("n", "p", "gamma", "tp", "tp_se", "fp", "fp_se", "f1", "f1_se", "miss", "miss_se", "time", "time_se")
out = data.frame(out)
i=1
ll = 0
lambda0_input = exp(seq(log(2^{-4}), log(2^{0}), length.out = 20))
lambda_theta_input = exp(seq(log(2^{-8}), log(2^{-6}), length.out = 20))
iter = 100
ll = ll + 1
en3_signal_varsel = en1_signal_varsel = matrix(0, iter, p_sig)
time3 = time10 = c()
en3_varsel = en1_varsel = c()
en3_tp = en3_fp = en1_tp = en1_fp = en3_f1 = en1_f1 = en3_rec = en1_rec = en3_pre = en1_pre = c()
en3_miss = en1_miss = c()
en3_time = en1_time = c()
# cat("\n iteration :", i, "\n")
set.seed(i)
tr = data_generation(n, p, SNR = 9, response = "continuous")
tr_x = tr$x
tr_y = tr$y
te = data_generation(te_n, p, SNR = 9, response = "continuous")
te_x = te$x
te_y = te$y
fit3 = try(cossonet(tr_x, tr_y, family = 'gaussian', gamma = 1, kernel = "spline", scale = T,
lambda0 = lambda0_input,
lambda_theta = lambda_theta_input
), silent = TRUE)
remove.packages("cossonet")
install.packages("cossonet")
library(cossonet)
library(tmvtnorm)
library(glmnet)
library(cosso)
library(MASS)
n = 100
te_n = 1000
p_sig = 4
p = 160
out2 = out
out = matrix(0, 24, 13)
colnames(out) = c("n", "p", "gamma", "tp", "tp_se", "fp", "fp_se", "f1", "f1_se", "miss", "miss_se", "time", "time_se")
out = data.frame(out)
i=1
ll = 0
lambda0_input = exp(seq(log(2^{-4}), log(2^{0}), length.out = 20))
lambda_theta_input = exp(seq(log(2^{-8}), log(2^{-6}), length.out = 20))
iter = 100
ll = ll + 1
en3_signal_varsel = en1_signal_varsel = matrix(0, iter, p_sig)
time3 = time10 = c()
en3_varsel = en1_varsel = c()
en3_tp = en3_fp = en1_tp = en1_fp = en3_f1 = en1_f1 = en3_rec = en1_rec = en3_pre = en1_pre = c()
en3_miss = en1_miss = c()
en3_time = en1_time = c()
# cat("\n iteration :", i, "\n")
set.seed(i)
tr = data_generation(n, p, SNR = 9, response = "continuous")
tr_x = tr$x
tr_y = tr$y
te = data_generation(te_n, p, SNR = 9, response = "continuous")
te_x = te$x
te_y = te$y
f1 = function(t) t
f2 = function(t) (2 * t - 1)^2
f3 = function(t) sin(2 * pi * t) / (2 - sin(2 * pi * t))
f4 = function(t) 0.1*sin(2 * pi * t) + 0.2*cos(2 * pi * t) + 0.3*sin(2 * pi * t)^2 + 0.4*cos(2 * pi * t)^3 + 0.5*sin(2 * pi * t)^3
f5 = function(t) sin(2 * pi * t) / (2 - sin(2 * pi * t)) + .5
f6 = function(t) 0.1*sin(2 * pi * t) + 0.2*cos(2 * pi * t) + 0.3*sin(2 * pi * t)^2 + 0.4*cos(2 * pi * t)^3 + 0.5*sin(2 * pi * t)^3 + .5
if(missing(n)) n = 200
if(missing(p)) p = 10
t = 2
pp = 4
x = matrix(0, n, pp)
W = matrix(runif(n * pp), n, pp)
U = runif(n)
for(j in 1:pp){
x[, j] = (W[, j] + t * U)/(1 + t)
}
V_sig = var(1 * f1(x[,1])) + var(1 * f2(x[,2])) + var(2 * f3(x[,3])) + var(3 * f4(x[,4]))
sd = sqrt(V_sig / SNR)
f = 1 * f1(x[,1]) + 1 * f2(x[,2]) + 2 * f3(x[,3]) + 3 * f4(x[,4]) + rnorm(n, 0, sd)
x_nois = matrix(runif(n * (p-pp), 0, 1), n, (p-pp))
x = cbind(x, x_nois)
SNR=8
V_sig = var(f1(x[,1])) + var(f2(x[,2])) + var(f3(x[,3])) + var(f4(x[,4])) +
var(f1(x[, 3] * x[, 4])) + var(f2((x[, 1] + x[, 3])/2)) + var(f3(x[, 1] * x[, 2]))
sd = sqrt(V_sig / SNR)
V_sig = var(f1(x[,1])) + var(f2(x[,2])) + var(f3(x[,3])) + var(f4(x[,4])) +
var(f1(x[, 3] * x[, 4])) + var(f2((x[, 1] + x[, 3])/2)) + var(f3(x[, 1] * x[, 2]))
sd = sqrt(V_sig / SNR)
f = f1(x[,1]) + f2(x[,2]) + f3(x[,3]) + f4(x[,4]) +
f1(x[, 3] * x[, 4]) + f2((x[, 1] + x[, 3])/2) + f3(x[, 1] * x[, 2]) + rnorm(n, 0, sd)
f
plot(f)
x_nois = matrix(runif(n * (p-pp), 0, 1), n, (p-pp))
#' The function data_generation generates an example dataset for applying the cossonet function.
#'
#' @param n observation size.
#' @param p dimension.
#' @param rho a positive integer indicating the correlation strength for the first four informative variables.
#' @param SNR signal-to-noise ratio.
#' @param response the type of the response variable.
#'
#' @return a list of explanatory variables, response variables, and true functions.
#'
#' @examples
#' # Generate example data
#' set.seed(20250101)
#' tr = data_generation(n = 200, p = 20, SNR = 9, response = "continuous")
#' tr_x = tr$x
#' tr_y = tr$y
#'
#' te = data_generation(n = 1000, p = 20, SNR = 9, response = "continuous")
#' te_x = te$x
#' te_y = te$y
#'
#' @export
#'
data_generation = function(n, p, rho, SNR,
response = c("continuous", "binary", "count", "survival"),
interaction = TRUE){
if(response == "binary"){
f1 = function(t) 3 * t
f2 = function(t) pi * sin(pi * t) * 2
f3 = function(t) 8 * t^3
f4 = function(t) 4/ (exp(1) - 1) * exp(t)
} else{
f1 = function(t) t
f2 = function(t) (2 * t - 1)^2
f3 = function(t) sin(2 * pi * t) / (2 - sin(2 * pi * t))
f4 = function(t) 0.1*sin(2 * pi * t) + 0.2*cos(2 * pi * t) + 0.3*sin(2 * pi * t)^2 + 0.4*cos(2 * pi * t)^3 + 0.5*sin(2 * pi * t)^3
f5 = function(t) sin(2 * pi * t) / (2 - sin(2 * pi * t)) + .5
f6 = function(t) 0.1*sin(2 * pi * t) + 0.2*cos(2 * pi * t) + 0.3*sin(2 * pi * t)^2 + 0.4*cos(2 * pi * t)^3 + 0.5*sin(2 * pi * t)^3 + .5
}
if(missing(response))
type = "continuous"
response = match.arg(response)
if(missing(n)) n = 200
if(missing(p)) p = 10
if(missing(rho)) rho = 0.8
if(missing(SNR)) SNR = 8
if(p <= 4) stop("dimension size should be larger than 4.")
t = 2
pp = 4
x = matrix(0, n, pp)
W = matrix(runif(n * pp), n, pp)
U = runif(n)
for(j in 1:pp){
x[, j] = (W[, j] + t * U)/(1 + t)
}
# Set the outer margins
# par(oma = c(0, 0, 0, 0))
# Set the inner margin
# par(mar = c(4, 4, 3, 1))
# par(mfrow = c(1,4))
# curve(f1, 0, 1)
# curve(f2, 0, 1)
# curve(f3, 0, 1)
# curve(f4, 0, 1)
# par(mfrow = c(1,1))
if(response == "continuous"){
if(interaction){
V_sig = var(1 * f1(x[,1])) + var(1 * f2(x[,2])) + var(2 * f3(x[,3])) + var(3 * f4(x[,4]))
sd = sqrt(V_sig / SNR)
f = 1 * f1(x[,1]) + 1 * f2(x[,2]) + 2 * f3(x[,3]) + 3 * f4(x[,4]) + rnorm(n, 0, sd)
x_nois = matrix(runif(n * (p-pp), 0, 1), n, (p-pp))
x = cbind(x, x_nois)
out = list(x = x, f = f, y = f)
}
else{
V_sig = var(f1(x[,1])) + var(f2(x[,2])) + var(f3(x[,3])) + var(f4(x[,4])) +
var(f1(x[, 3] * x[, 4])) + var(f2((x[, 1] + x[, 3])/2)) + var(f3(x[, 1] * x[, 2]))
sd = sqrt(V_sig / SNR)
f = f1(x[,1]) + f2(x[,2]) + f3(x[,3]) + f4(x[,4]) +
f1(x[, 3] * x[, 4]) + f2((x[, 1] + x[, 3])/2) + f3(x[, 1] * x[, 2]) + rnorm(n, 0, sd)
x_nois = matrix(runif(n * (p-pp), 0, 1), n, (p-pp))
x = cbind(x, x_nois)
out = list(x = x, f = f, y = f)
}
}
if(response == "binary"){
V_sig = var(f1(x[,1])) + var(f2(x[,2])) + var(f3(x[,3])) + var(f4(x[,4]))
sd = sqrt(V_sig / SNR)
f = f1(x[,1]) + f2(x[,2]) + f3(x[,3]) + f4(x[,4]) - 11 + rnorm(n, 0, sd)
x_nois = matrix(runif(n * (p-4), 0, 1), n, (p-4))
x = cbind(x, x_nois)
prob = exp(f)/(exp(f) + 1)
y = rbinom(n, 1, prob)
out = list(x = x, f = f, y = y)
}
if(response == "count"){
V_sig = var(1 * f1(x[,1])) + var(1 * f2(x[,2])) + var(2 * f5(x[,3])) + var(3 * f6(x[,4]))
sd = sqrt(V_sig / SNR)
f = 1 * f1(x[,1]) + 1 * f2(x[,2]) + 2 * f5(x[,3]) + 3 * f6(x[,4]) + rnorm(n, 0, sd)
# print(sd)
x_nois = matrix(runif(n * (p-pp), 0, 1), n, (p-pp))
x = cbind(x, x_nois)
f = f / 3
mu = exp(f)
y = rpois(n, mu)
out = list(x = x, f = f, y = y)
}
if(response == 'survival'){
V_sig = var(1 * f1(x[,1])) + var(1 * f2(x[,2])) + var(2 * f3(x[,3])) + var(3 * f4(x[,4]))
sd = sqrt(V_sig / SNR)
f = 1 * f1(x[,1]) + 1 * f2(x[,2]) + 2 * f3(x[,3]) + 3 * f4(x[,4]) + rnorm(n, 0, sd)
x_nois = matrix(runif(n * (p - pp), 0, 1), n, (p - pp))
x = cbind(x, x_nois)
surTime = rexp(n, exp(f))
cenTime = rexp(n, exp(-f) * runif(1, 4, 6))
y = cbind(time = apply(cbind(surTime, cenTime), 1, min), status = 1 * (surTime < cenTime))
out = list(x = x, f = f, y = y)
}
return(out)
}
tr = data_generation(n, p, SNR = 9, response = "continuous", interaction = TRUE)
tr_x = tr$x
tr_y = tr$y
te = data_generation(te_n, p, SNR = 9, response = "continuous", interaction = TRUE)
te_x = te$x
te_y = te$y
fit3 = try(cossonet(tr_x, tr_y, family = 'gaussian', gamma = 1, kernel = "spline", scale = T,
lambda0 = lambda0_input,
lambda_theta = lambda_theta_input
), silent = TRUE)
fit3 = try(cossonet(tr_x, tr_y, family = 'gaussian', gamma = 1, kernel = "spline2", scale = T,
lambda0 = lambda0_input,
lambda_theta = lambda_theta_input
), silent = TRUE)
effect = interaction", scale = T,
fit3 = try(cossonet(tr_x, tr_y, family = 'gaussian', gamma = 1, kernel = "spline",
effect = "interaction", scale = T,
lambda0 = lambda0_input,
lambda_theta = lambda_theta_input
), silent = TRUE)
fit3
p
p=20
tr = data_generation(n, p, SNR = 9, response = "continuous", interaction = TRUE)
tr_x = tr$x
tr_y = tr$y
te = data_generation(te_n, p, SNR = 9, response = "continuous", interaction = TRUE)
te_x = te$x
te_y = te$y
fit3 = try(cossonet(tr_x, tr_y, family = 'gaussian', gamma = 1, kernel = "spline",
effect = "interaction", scale = T,
lambda0 = lambda0_input,
lambda_theta = lambda_theta_input
), silent = TRUE)
fit3
fit3 = try(cossonet(tr_x, tr_y, family = 'gaussian', gamma = 1, kernel = "spline",
effect = "interaction", scale = T,
lambda0 = lambda0_input,
lambda_theta = lambda_theta_input
), silent = TRUE)
#' Load a matrix from a file
#'
#' The cossonet function implements a nonparametric regression model that estimates nonlinear components.
#' This function can be applied to continuous, count, binary, and survival responses.
#' To use this function, the user must specify a family, kernel function, etc. For cross-validation, the sequence vectors `lambda0` and `lambda_theta` appropriate for the input data must also be specified.
#'
#' @param x Input matrix or data frame of $n$ by $p$. `x` must have at least two columns ($p>1$).
#' @param y A response vector with a continuous, binary, or count type. For survival responses, this should be a two-column matrix (or data frame) with columns called 'time' and 'status'.
#' @param family A distribution corresponding to the response type. `family="gaussian"` for continuous responses, `family="binomial"` for binary responses, `family="poisson"` for count responses, and `family="cox"` for survival responses.
#' @param wt The weights assigned to the explanatory variables. The default is `rep(1,ncol(x))`.
#' @param scale Boolean for whether to scale continuous explanatory variables to values between 0 and 1.
#' @param nbasis The number of "knots". If `basis.id` is provided, it is set to the length of `basis.id`.
#' @param basis.id The index of the "knot" to select.
#' @param kernel TThe kernel function. One of four types of `linear` (default), `gaussian`, `poly`, and `spline`.
#' @param effect The effect of the component. `main` (default) is the main effect, and `interaction` is the two-way interaction.
#' @param nfold The number of folds to use in cross-validation is used to determine how many subsets to divide the data into for the training and validation sets.
#' @param kparam Parameters for Gaussian and polynomial kernel functions
#' @param lambda0 A vector of `lambda0` sequences. The default is a grid of 20 values `[2^{-10}, \dots, 2^{10}]` on an equally spaced logarithmic scale. This may need to be adjusted based on the input data. Do not set `\lambda0` as a single value.
#' @param lambda_theta A vector of `lambda` sequences. The default is a grid of 20 values `[2^{-10}, \dots, 2^{10}]` on an equally spaced logarithmic scale. This may need to be adjusted based on the input data. Do not set `lambda` as a single value.
#' @param gamma Elastic-net mixing parameter `0 \leq \gamma \leq 1`. If `gamma = 1`, the LASSO penalty is applied, and if `gamma = 0`, the Ridge penalty is applied. The default is `gamma = 0.95`.
#' @param one.std A logical value indicating whether to apply the "1-standard error rule." When set to `TRUE`, it applies to both the c-step and theta-step, selecting the simplest model within one standard error of the best model.
#' @return A list containing information about the fitted model.
#'
#' @examples
#' \donttest{
#' # Generate example data
#' set.seed(20250101)
#' tr = data_generation(n = 200, p = 20, SNR = 9, response = "continuous")
#' tr_x = tr$x
#' tr_y = tr$y
#'
#' te = data_generation(n = 1000, p = 20, SNR = 9, response = "continuous")
#' te_x = te$x
#' te_y = te$y
#'
#' # Fit the model
#' fit = cossonet(tr_x, tr_y, family = 'gaussian', gamma = 0.95, kernel = "spline", scale = TRUE,
#'       lambda0 = exp(seq(log(2^{-4}), log(2^{0}), length.out = 20)),
#'       lambda_theta = exp(seq(log(2^{-8}), log(2^{-6}), length.out = 20))
#'       )
#'
#' }
#' @export
#'
cossonet = function (x,
y,
family = c("gaussian", "binomial", "poisson", "Cox"),
wt = rep(1, ncol(x)),
scale = TRUE,
nbasis,
basis.id,
kernel = c("linear", "gaussian", "poly", "spline"),
effect = c("main", "interaction"),
nfold = 5,
kparam = 1,
lambda0 = exp(seq(log(2^{-10}), log(2^{10}), length.out = 20)),
lambda_theta = exp(seq(log(2^{-10}), log(2^{10}), length.out = 20)),
gamma = 0.95,
one.std = TRUE)
{
n = nrow(x)
colnames(x) = NULL
rownames(x) = NULL
if(!(class(x)[1] %in% c("matrix", "data.frame")))
stop("A input x must be matrix or data frame.")
# family
family = match.arg(family)
if(family == "gaussian")
obj = gaussian()
if(family == "binomial")
obj =  binomial()
if(family == "poisson")
obj = poisson()
if(missing(kernel))
type = 'spline'
else
type = match.arg(kernel)
if(missing(effect))
effect = 'main'
else
effect = match.arg(kernel)
if(effect == "interaction") type = paste0(kernel, "2")
if(scale)
x = apply(x, 2, rescale)
if (family == "Cox" & !all(match(c("time", "status"), dimnames(y)[[2]], 0))) {
stop("Cox model requires a matrix with columns 'time' and 'status' as a response")
}
objnm = ifelse(family == 'gaussian' | family == 'binomial' | family == 'poisson', 'glm', "Cox")
# fitting
out = switch(objnm,
glm = cossonet.exp(x, y, wt, nbasis, basis.id, lambda0, lambda_theta, gamma, obj, type, nfold, kparam, scale, one.std),
Cox = cossonet.cox(x, unlist(y[, "time"]), unlist(y[, "status"]), nbasis, basis.id, wt, lambda0, lambda_theta, gamma, type, nfold, kparam, scale, one.std)
)
attr(out, "class") = "cossonet"
return(out)
}
s
fit3 = try(cossonet(tr_x, tr_y, family = 'gaussian', gamma = 1, kernel = "spline",
effect = "interaction", scale = T,
lambda0 = lambda0_input,
lambda_theta = lambda_theta_input
), silent = TRUE)
fit3
remove.packages("cossonet")
